"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var visit = require(`unist-util-visit`);
var isRelativeUrl = require(`is-relative-url`);
var fsExtra = require(`fs-extra`);
var path = require(`path`);
var _ = require(`lodash`);
var $ = require(`cheerio`);

module.exports = function (_ref) {
  var files = _ref.files,
      markdownNode = _ref.markdownNode,
      markdownAST = _ref.markdownAST,
      getNode = _ref.getNode;

  var filesToCopy = new Map();
  // Copy linked files to the public directory and modify the AST to point to
  // new location of the files.
  var visitor = function visitor(link) {
    if (isRelativeUrl(link.url) && getNode(markdownNode.parent).internal.type === `File`) {
      var linkPath = path.join(getNode(markdownNode.parent).dir, link.url);
      var linkNode = _.find(files, function (file) {
        if (file && file.absolutePath) {
          return file.absolutePath === linkPath;
        }
        return null;
      });
      if (linkNode && linkNode.absolutePath) {
        var newPath = path.join(process.cwd(), `public`, `${linkNode.internal.contentDigest}.${linkNode.extension}`);
        var relativePath = path.join(`/${linkNode.internal.contentDigest}.${linkNode.extension}`);
        link.url = `${relativePath}`;

        filesToCopy.set(linkPath, newPath);
      }
    }
  };

  visit(markdownAST, `link`, function (link) {
    visitor(link);
  });

  // Also copy gifs since Sharp can't process them as well as svgs since we
  // exclude them from the image processing pipeline in
  // gatsby-remark-images. This will only work for markdown img tags
  visit(markdownAST, `image`, function (image) {
    var imagePath = path.join(getNode(markdownNode.parent).dir, image.url);
    var imageNode = _.find(files, function (file) {
      if (file && file.absolutePath) {
        return file.absolutePath === imagePath;
      }
      return false;
    });
    if (imageNode && (imageNode.extension === `gif` || imageNode.extension === `svg`)) {
      visitor(image);
    }
  });

  // Same as the above except it only works for html img tags
  visit(markdownAST, `html`, function (node) {
    if (node.value.startsWith(`<img`)) {
      var image = Object.assign(node, $.parseHTML(node.value)[0].attribs);
      image.url = image.src;
      image.type = `image`;
      image.position = node.position;

      var imagePath = path.join(getNode(markdownNode.parent).dir, image.url);
      var imageNode = _.find(files, function (file) {
        if (file && file.absolutePath) {
          return file.absolutePath === imagePath;
        }
        return false;
      });
      if (imageNode && (imageNode.extension === `gif` || imageNode.extension === `svg`)) {
        visitor(image);
      }
    }
  });

  return Promise.all(Array.from(filesToCopy, function () {
    var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(_ref2) {
      var linkPath = _ref2[0],
          newPath = _ref2[1];
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (fsExtra.existsSync(newPath)) {
                _context.next = 9;
                break;
              }

              _context.prev = 1;
              _context.next = 4;
              return fsExtra.copy(linkPath, newPath);

            case 4:
              _context.next = 9;
              break;

            case 6:
              _context.prev = 6;
              _context.t0 = _context["catch"](1);

              console.error(`error copying file`, _context.t0);

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, undefined, [[1, 6]]);
    }));

    return function (_x) {
      return _ref3.apply(this, arguments);
    };
  }()));
};